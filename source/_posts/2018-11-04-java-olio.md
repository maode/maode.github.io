---
title: Java知识点杂记、位操作、字节序
date: Sun Nov 04 2018 10:23:38
tags:
	- Java
	- 位操作
	- 字节序
---

## 字节序相关
**通常不用太关心字节序问题，在多编程语言多程序数据通信传输时，需关心一下，约定统一字节序。**

主机字节序：
- IA架构(Intel、AMD)的CPU中是Little-Endian，而PowerPC 、SPARC和Motorola处理器是Big-Endian
- java取当前主机字节序的方法是：ByteOrder.nativeOrder()

**HotSpot VM默认字节序是大端序。**

## java类型转换
java大范围类型向小范围类型转换--溢出时，都是丢弃高有效位数据，保留低有效位数据。
java小范围类型向大范围类型转换--字节数由少变多，有效位字节放到高位字节处（即：【大端序】内存的低地址，字节数组的高索引），低位字节补0。
（个人感觉java和C++的类型转换处理机制应该是一样的，最起码java是这样，C++没有进行验证只是猜测。只是字节序不一样，但是字节序和类型转换没有任何关系，只是转换完的数据在内存中存储地址是相反的）



## 原码反码补码

**正数的 原码、反码、补码 相同**

### 原码：
原码是指数字的一种二进制表示形式。在[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6 "二进制")数左边加上符号位后所得到的码。
- 二进制数为正数时，符号位为0；
- 二进制数为负数时，符号位为1；
- 二进制数等于0时，符号位可以为0或1(即：`+0`/`-0`)

### 反码：
- 一个数如果是正,则它的反码与原码相同;
- 一个数如果是负(即：符号位为1),则符号位不变,其余各位是对原码取反;

### 补码：
- 一个数为正,则它的原码、反码、补码都相同
- 一个数为负,符号位为1,其余各位是对原码取反,然后`整个数`加1



## 与`0xFF`做`逻辑与`运算的目的
`oxFF`的二进制形式为：低8位全部为1，其余位全部为0，任何一个数与`0xFF`做`逻辑与`运算，则该数低8位值不变，其它位全部被置零。通常用于类型转换时将负数转换为应的正数表现形式。

如：`-1`对应的无符号数为`255`

java中的负数是以补码的形式表现的，-1的原码`10000001` --> -1的补码`1111111`,如此时做类型转换，如byte转short，一个字节变成2个字节，多出的字节进行补位，java中会对有符号数补符号位，即：`11111111,11111111`，与`0xFF`做逻辑与运算，即`111111111,11111111`&`00000000,11111111`结果为：`00000000,11111111`即255。这就实现了-1向255的转化。




## 位操作运算
|符号|描述|运算规则|
|:-|:-|:-|
| `&`   | 与 | 两个位都为1时，结果才为1 |
| <code>|</code>   | 或 | 两个位都为0时，结果才为0 |
| `~`   | 非 | 0变1，1变0 (也叫`取反`)|
| `^`   | 异或 | 两个位相同为0，相异为1 |
| `<<` | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0 |
| `<<` | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

`<<`左移运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位向左跟进，产生的空位补零。
`>>`右移运算规则：按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位向右跟进，产生的空位补符号位，即正数补零，负数补1。

<!-- more -->

## 集合

### Map
`HashMap`：轻量级 线程不安全 允许key或者value是null
`Hashtable`：重量级 线程安全 不允许key或者value是null
`Properties`：Hashtable的子类，key和value都是String 

### List
- `ArrayList`：底层用动态数组实现
特点：查询效率高（随意访问或顺序访问），增删效率低，整体清空快。 轻量级 线程不安全。数组长度是可变的百分之五十延长
- `LinkedList`：底层用双向循环链表 实现的List
特点：查询效率低，增删效率高。线程不安全。
- `Vector`: 底层用动态数组实现
特点：重量级，增删查都慢，占据更多的系统开销。被ArrayList替代。长度任意延长。线程安全（同步的类，函数都是synchronized）。
- `Stack`：继承于Vector
特点：（实现堆栈）先进后出。一般不用请用LinkedList或Queue接口的其它实现类。

### Set

- `HashSe`t：采用哈希算法来实现Set接口
特点：无序，集合中查询某个对象是否存在，HashSet的速度最快。线程不安全。
唯一性保证：重复对象equals方法返回为true重复对象hashCode方法返回相同的整数。
注意：不同对象 哈希码 尽量保证不同（提高效率）

- `TreeSet`：使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序
特点：在元素添加的同时，进行排序。线程不安全。
唯一性保证：根据排序规则，compareTo方法返回为0，就可以认定两个对象中有一个是重复对象。



## 获取时间的方式：
//方法一 速度最快
`System.currentTimeMillis();`
//方法二 比方法一慢，低于一倍的时间
`new Date().getTime();`
//方法三 速度最慢，Canlendar处理时区耗时
`Calendar.getInstance().getTimeInMillis(); `



## 魔数（magic number）

参考：https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)

Magic number一般是指[硬编码](https://zh.wikipedia.org/wiki/%E5%AF%AB%E6%AD%BB "硬编码")在代码里的具体数值（如“10”“123”等以数字直接写出的值）。虽然程序作者写的时候自己能了解数值的意义，但对其他程序员而言，甚至制作者本人经过一段时间后，会难以了解这个数值的用途，只能苦笑讽刺“这个数值的意义虽然不懂，不过至少程序能够运行，真是个魔术般的数字”而得名（起源参考[平方根倒数速算法](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E9%80%9F%E7%AE%97%E6%B3%95 "平方根倒数速算法")）。

因为下述理由，一般认为代码中不应该含有魔术数字。

*   数值的意义难以了解
*   数值需要变动时，可能要改不只一个地方




